module MQTT_TestingSystem {
	modulepar {
        charstring tsp_hostname := "test.mosquitto.org"  
        charstring tsp_url := "/mqtt" 
        boolean    tsp_use_ssl := false 
        integer    tsp_remPort := 8080 
        integer    tsp_remPort_s := 8081
    }

	import from IPL4asp_Types all;
    import from IPL4asp_PortType all;
    import from MQTT_v3_1_1_Types all;
    import from MQTT_v3_1_1_IPL4SizeFunction all;
    import from MQTT_IPL4_translation all;
    import from MQTT_User_CtrlFunct all;

    type port User_PT message {
      	inout charstring
    } with { extension "internal" }

    type component User_CT {
    	port  User_PT User_PCO; 
    }

    type component MQTT_CT {
        port  User_PT      User_PCO; 
        port  MQTT_IPL4_PT MQTT_PCO; 
        timer t;    
        var IPL4asp_Types.Result  c_res:= { errorCode := omit, connId  := omit, os_error_code:=omit, os_error_text:= omit };   
        var ASP_RecvFrom v_ASP_RecvFrom
        var ASP_Event v_ASP_Event	
      
        var MQTT_v3_1_1_Message v_msg
        var octetstring v_ws_pdu:=''O, v_mqtt;
        var IPL4asp_Types.Result  vl_result; 
        var integer v_cid, v_ret;
        var  TCPState v_TCPState:=Disconnected;
        var MQTTClientState v_state 
        var charstring v_ctrl
    }
    
    type component System_CT {
     	port IPL4asp_PT IPL4_PCO;
    }

	template PortEvent  t_connClose := { connClosed := { connId := ?, remName := ?, remPort := ?, locName := ?, locPort := ?, proto := { tcp := { } }, userData := ? } }


	function f_preamble() runs on MQTT_CT system System_CT {
        vl_result := c_res;
      
        if(tsp_use_ssl) {
        	vl_result :=MQTT_User_CtrlFunct.f_IPL4_connect(MQTT_PCO, tsp_hostname, tsp_remPort_s,"",0, -1, {ssl := {} }, {}  );  
        } else {
            vl_result :=MQTT_User_CtrlFunct.f_IPL4_connect( MQTT_PCO, tsp_hostname, tsp_remPort,"",0, -1, {tcp := {} }, {} ); 
        }
      
        log("connect result",vl_result);
        
        if (not(ispresent(vl_result.connId))) {
            log("Could not connect TCP/TLS");
            stop;
        } else {
        	v_TCPState:=Connected  	
        }
      
        v_cid:=vl_result.connId; 
      
        //register message length function of MQTT with IPL4:
        //*************************************************************************
        var f_IPL4_getMsgLen getMsg_Func := refers(f_GetMsgLengthMQTT);
        MQTT_User_CtrlFunct.f_IPL4_setGetMsgLen(MQTT_PCO,v_cid, getMsg_Func, {});
        //*************************************************************************
	}

	function f_postamble() runs on MQTT_CT system System_CT {
  		//close  TCP/TLS connection if needed

        if(v_TCPState==Connected) {
            vl_result :=    MQTT_User_CtrlFunct.f_IPL4_close(MQTT_PCO, v_cid)
            log("close result",vl_result) 
          
            v_TCPState:=Disconnected;
        }
    }

    altstep as_default() runs on MQTT_CT  system System_CT { 
        [] MQTT_PCO.receive(t_publish_r0 ) -> value v_msg { 
            log("Test publish  MQTT response 'test' received<<-------------------- : ",v_msg);
            repeat;
        }
      
        [] MQTT_PCO.receive(t_publish_r1 ) -> value v_msg { 
            log("Test publish  MQTT response ''testdiff' received<<-------------------- : ",v_msg);
            repeat;
        }
        
        []  MQTT_PCO.receive(t_connClose) {
        	v_TCPState:=Disconnected
        }
      
        []  MQTT_PCO.receive(PortEvent:?) {
          	log("Port Event received")
        }
        
        [] t.timeout{  
        	log("Timeout")
        }
    }

    function f_UserBehaviour()  runs on User_CT {
		alt {
    		[]User_PCO.receive("Ready") {
          		User_PCO.send("Breathe, breathe in the air")
    		}
      	}
    }
}
